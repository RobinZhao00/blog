{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"小马达","url":"http:www.zhaoyua.com"},"pages":[],"posts":[{"title":"小程序api的promisefy","slug":"小程序api的promisefy","date":"2018-12-02T05:39:24.000Z","updated":"2018-12-02T07:06:41.675Z","comments":true,"path":"2018/12/02/小程序api的promisefy/","link":"","permalink":"http:www.zhaoyua.com/2018/12/02/小程序api的promisefy/","excerpt":"","text":"需求背景 微信小程序的大部分api是异步的。 简单地举个🌰: wx.showToast(Object object)1234567 wx.showToast(&#123; title: '成功', icon: 'success', duration: 2000, success: function(res) &#123; // TODO &#125;, fail: function(err) &#123; // TODO &#125;&#125;); &nbsp;&nbsp;&nbsp;&nbsp;事实上这样的api 写的真够好，但是对于使用者来说并不友好。所以，为了方便同事们更加舒爽地去写代码，于是我开始琢磨封装一个小程序api的promisefy的函数。 &nbsp;&nbsp;&nbsp;&nbsp; 那么到底怎么封装呢？123456789101112// defaultProps为默认属性，extraProps为定制化的属性/*** promisefy 微信内置函数* @param fn* @return &#123; promise &#125;*/ const promisefy = fn =&gt; defaultProps =&gt; extraProps =&gt; new Promise((resolve, reject) =&gt; fn(&#123; ...defaultProps, ...extraProps, success: res =&gt; resolve(res), reject: err =&gt; reject(err), &#125;)); &nbsp;&nbsp;&nbsp;&nbsp; 那么到底怎么使用呢？123456789const showToast = promisefy(wx.showToast)(&#123; title: '', icon: \"none\", duration: 2000, confirmColor: '#ff673f', mask: true&#125;);showToast(&#123; title: 'title' &#125;); // 即可使用 &nbsp;&nbsp;&nbsp;&nbsp; 那么这个promisefy还能怎么用呢？1.我们可能会经常使用storage相关的api， 那么到底是把对象JSON.stringify, 再setStorage。需要使用的时候再getStorage, 最后JSON.parse呢？当然这是一种解决方案。如果使用promisefy，可以这样干。123456789101112131415/** * * @param 需要往LocalStorage里面存数据 * @returns &#123;Promise&lt;any[] | never&gt;&#125; */const setStorage = (param = &#123;&#125;) =&gt; &#123; if (!Object.keys(param).length) throw new Error('输入的对象不为空'); return Promise.all(Object.entries(param) .map(item =&gt; promisefy(wx.setStorage)(&#123; key: item[0], data: item[1] &#125;)()));&#125;;setStorage(&#123; a:1, b:2 &#125;); 123456789101112131415/** * * @param 需要从storage 读取的key。 * 单个值直接传string, 多个值传数组 * eg. ['key1', 'key2', 'key3'] 或者 'key1' ; * @returns &#123;key1: value1, key2: value2, key3: key3 &#125; */const getStorage = param =&gt; Promise.all( Object.entries(((typeof param) === 'string') ? [param] : param) .map(item =&gt; promisefy(wx.getStorage)(&#123; key: item[1] &#125;)() .then(res =&gt; (&#123; [`$&#123;item[1]&#125;`]: res.data &#125;)))) .then(res =&gt; res.reduce((prev, curr) =&gt; (&#123; ...prev, ...curr &#125;), &#123;&#125;));getStorage('a'); // &#123; a: 1 &#125;,getStorage(['a', 'b']); // &#123; a: 1, b: 2 &#125;, 123456789/** * @param 需要从storage 清除记录eg. [key1, key2], key3。 */const removeStorage = param =&gt; Promise.all( Object.entries(((typeof param) === 'string') ? [param] : param) .map(item =&gt; promisefy(wx.removeStorage)(&#123; key: item[1] &#125;)()));removeStorage('a');removeStorage(['a', 'b']); 2.对于有router 的页面我们经常会出现router 的三种跳转方案。例如微信就提供了三种api:navigateTo，redirectTo，navigateBack，这里没有包含小程序跳小程序的api。那么我们是不是可以封装一个公共的方法呢？12345678910111213141516171819202122232425262728293031323334353637383940414243// 路径参数的拼接const obj2Url = params =&gt; &#123; if (params instanceof Array || typeof params === 'number') throw new Error('跳转参数限制于string和对象'); // 如果路径参数为 object, 做以下转换 if (typeof params === 'object') &#123; const rawParams = Object.entries(params).reduce((acc, cur) =&gt; &#123; if ((!cur[1]) &amp;&amp; ((typeof cur[1]) !== 'boolean')) console.warn(`$&#123;cur[0]&#125;的值为空， 请检查原因！`); return `$&#123;acc + cur[0]&#125;=$&#123;cur[1]&#125;&amp;`; &#125;, ''); params = rawParams.substr(0, rawParams.length - 1); &#125; return params;&#125;;/** * * @param page 需要跳转的页面或者页面路径(如果是\"pages/a/b/b\"这样的路径，page='pages/a/b/b', specialUrl=true ) * @param type * @param params * @param specialUrl * @return &#123;*&#125; */const jumpTo = (page = 'index', type = 'navigate', params = '', specialUrl = false) =&gt; &#123; const &#123; navigateTo, redirectTo, navigateBack &#125; = wx; const types = &#123; navigate: url =&gt; promisefy(navigateTo)(&#123; url &#125;)(), redirect: url =&gt; promisefy(redirectTo)(&#123; url &#125;)(), back: delta =&gt; promisefy(navigateBack)(&#123; delta &#125;)(), &#125;; params = obj2Url(params); console.log('**test**', 'params', params, `$&#123;page&#125;?$&#123;params&#125;`); if (specialUrl) return types[type](params ? `$&#123;page&#125;?$&#123;params&#125;` : page); // 获取跳转参数，如果为数字，则为navigateBack，反之为 navigateTo 或 navigateBack。 const jumpPram = (typeof page === 'number') ? page : `/pages/$&#123;page&#125;/$&#123;page&#125;$&#123;params ? `?$&#123;params&#125;` : ''&#125;`; console.log(`%c**跳转参数**jumpPram** $&#123;jumpPram&#125;`, 'color:white;background:green'); sendTrack(`**跳转参数**jumpParam** $&#123;jumpPram&#125;`); return types[type](jumpPram);&#125;;jumpTo('a'); // navigateTo到a页面jumpTo('a', 'navigate', &#123; m: 'm' &#125;); // navigateTo到a页面 ,路径参数为?m=mjumpTo('a', 'redirect', &#123; m: 'm' &#125;); // redirectTo到a页面 ,路径参数为?m=mjumpTo(1, 'redirect', &#123; m: 'm' &#125;); // back 上一步 ,路径参数为?m=m 项目实践 1.native 小程序开发者。（下载babel-polyfill，导入regeneratorRuntime） 1234567891011121314151617181920212223242526272829303132333435import regeneratorRuntime from '你放置的文件夹';const showLoading = promisefy(wx.showLoading)(&#123; title: '加载中', mask: true &#125;);const hideLoading = () =&gt; wx.hideLoading();const showMoshowToast = promisefy(wx.showToast)(&#123; title: 'title', content: '', mask: true &#125;);const Loading = &#123; show: showLoading, hide: hideLoading &#125;;const Toast = &#123; show: showToast &#125;;const handleErr = (e, cb) =&gt; &#123; Loading.hide(); if ((typeof e) === 'string') &#123; Toast.show(&#123; title: e || '服务器异常，请稍后再试' &#125;); &#125; else &#123; const &#123; message &#125; = e; Toast.show(&#123; title: message || '服务器异常，请稍后再试' &#125;); &#125; cb &amp;&amp; cb();&#125;;const fetchData = () =&gt; &#123;&#125;aync function() &#123; try &#123; await Loading.show(); const &#123; data &#125; = await fetchData(); this.setData(&#123; data &#125;) Loading.hide(); &#125; catch (e) &#123; handleErr(e) &#125;&#125; 2.webpack和taro 用户直接引入用配置bable 相关npm即可, 可参考 总结分析 函数的科里化干了什么？ &nbsp;&nbsp;&nbsp;&nbsp;参考 科里化 怎么避免过多使用switch…case,if…else等？ &nbsp;&nbsp;&nbsp;&nbsp;参考 策略模式 扁平化数组操作。 &nbsp;&nbsp;&nbsp;&nbsp;参考 编写扁平化的代码 异常的处理。","categories":[],"tags":[]}]}